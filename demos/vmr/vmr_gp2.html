<!doctype html>
<html id="html">

  <head>
    <title>Motor Study</title>

    <!-- *** CSS *** -->
    <link rel='stylesheet' type='text/css' href='style.css'>

    <!-- *** BOWSER *** -->
    <script src="https://unpkg.com/bowser@2.4.0/es5.js"></script>
    
    <!-- *** GL-MATRIX *** -->
    <script src ='https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js'></script>

    <!-- *** SIZEOF *** >
    <script src="sizeof.js"></script-->
    
    <!-- *** WJS *** -->
    <script src="wjs_core_ec.js"></script>

    <!-- *** FIREBASE *** -->
    <script src='/__/firebase/8.10.0/firebase-app.js'></script>
    <script src='/__/firebase/8.10.0/firebase-auth.js'></script>
    <script src='/__/firebase/8.10.0/firebase-database.js'></script>
    <script src='/__/firebase/init.js?useEmulator=true'></script>

  </head>
  <body id="body">

    <div id="page-content" class="display-element">
      
      <div id="chrome-required-content">
        <p>Uh oh!<br>This experiment requires Google Chrome.<br>
        Please copy the full URL and reopen it in Chrome.<br>
        Thank you! We apologize for any inconvenience.</p>
      </div>
      
      <div id="desktop-required-content">
        <p>Uh oh!<br>This experiment is not supported on mobile devices.<br>
        Please open it on a computer using Google Chrome.<br>
        Thank you! We apologize for any inconvenience.</p>
      </div>

      <div id="consent-content">
        <p>Please read the consent form and agree by ticking the checkbox.</p>
        <iframe src="consent.pdf#zoom=75" width="90%" height="300px"></iframe>
        <div>
          <p style="font-size:10pt; margin:0">
            <a id="consent-link" href="consent.pdf" target="_blank" download="consent.pdf">
              Click here to download the pdf for your records.
            </a>
          </p>
          <form id="consent-form">
            <input type="checkbox" id="consent-checkbox" required>
            <label for="consent-checkbox">
              I agree to take part in this study.
            </label>
            <div><button class="button" id="consent-button" type="submit">Continue</button></div>
          </form>
          <div class="progressbar-spacer"></div>
        </div>
      </div>

      <div id="survey-content">
        <form id="survey-form">
          <p class="survey-q" id="workerId">Check that your worker ID is displayed correctly:</p>
          <input type="text" name="workerId" minlength=10 maxlength=21 required>

          <p class="survey-q" id="age">How old are you?</p>
          <input type="number" name="age" min="18" max="120" placeholder="18+ only" required>

          <p class="survey-q" id="gender">What is your gender?</p>
          <select name="gender" required>
            <option value="" disabled selected>Select your response</option>
            <option value="F">Female</option>
            <option value="M">Male</option>
            <option value="N">Nonbinary</option>
            <option value="X">Prefer not to say</option>
          </select>

          <p class="survey-q" id="inputdevice">Are you using a mouse or a trackpad?</p>
          <select name="inputdevice" required>
            <option value="" disabled selected>Select your response</option>
            <option value="Mouse">Mouse</option>
            <option value="Track">Trackpad</option>
            <!--option value="Touch">Touchscreen</option-->
          </select>

          <p class="survey-q" id="hand">Which hand to do you use to control the mouse/trackpad?</p>
          <select name="hand" required>
            <option value="" disabled selected>Select your response</option>
            <option value="R">Right</option>
            <option value="L">Left</option>
          </select>

          <div><button class="button" id="survey-button" type="submit" disabled>Continue</button></div>
        </form>
        <div class="progressbar-spacer"></div>
      </div>

      <div id="fullscreen-content">
        <h3>This experiment must be run in full-screen.</h3>
        <div><button id="fullscreen-button" class="button">Enter full screen mode</button></div>
        <div><button id="local-save-button-1" class="button">Save data</button></div>
        <div class="progressbar-spacer"></div>
      </div>
      
      <div id="pointerlock-content">
        <h3>This experiment requires your mouse pointer to be hidden.</h3>
        <div><button id="pointerlock-button" class="button">Hide the pointer</button></div>
        <div class="progressbar-spacer"></div>
      </div>

      <div id="instructions-content">
        <div class="instructions-text">
          <h3>Thank you for participating in our research on human motor control!</h3>
          <p class="instructions-bulleted">
            &bull; This game was designed to test your ability to control movements of the cursor.<br>
            &bull; You will aim a small cursor at various targets using the mouse or trackpad.<br>
            &bull; It may be challenging, but please keep trying because we want to see how much you can improve.<br>
            &bull; Please try to hit as many targets as possible until the game ends.<br>
          </p>
            <h4>Please note:</h4>
          <p class="instructions-bulleted">
            &bull; <i>If your data show that you are not trying or take a long break, your submission will be rejected.</i><br>
            &bull; <b>Accurate performance earns you a BIGGER BONUS and lets you FINISH FASTER.</b><br>
          </p>
        </div>
        <p style="margin-bottom: 0;">Click the button when you are ready to start.</p>
        <button class="button" id="instructions-button", disabled>Start</button>
        <div class="progressbar-spacer"></div>
      </div>

      <div id="trial-content">
        <canvas id="2d-canvas" style="z-index: 2"></canvas>
        <canvas id="3d-canvas"></canvas>
      </div>

      <div id="code-content">
        <h3 id="bonus-text"></h3>
        <h4>Return to MTurk and enter the following code to submit this HIT.</h4>
        <input type="text" value="" id="code-text" font-size=14pt width=100px readonly>
        <br>
        <button class="button" id="code-button">Copy code to clipboard</button>
        <div><button id="local-save-button-2" class="button">Save data</button></div>
        <div class="progressbar-spacer"></div>
      </div>
    </div>
    
    <div id="connection-content" class="display-element">
      <h3>Attempting to connect to data server. Please wait...</h3>
      <p>The game will resume automatically when you have reconnected.</p>
      <p>If nothing is happening, please check your internet connection.</p>
      <div class="progressbar-spacer"></div>
    </div>

    <div id="progressbar-container">
      <span>Time Elapsed: <label id="minutes">00</label>:<label id="seconds">00</label><br></span>
      <div id="progressbar-outer">
        <div id="progressbar-inner">
        </div>
      </div>
    </div>

    <script>
      'use strict';
      var workerId = getWorkerId();
      
      // IMPORTANT: expName must match the experiment name in your project directory
      var expName = 'vmr_gp2';
      
      // IMPORTANT: Set to false before deploying
      var logFlag = false; // print messages to debug console?
      if (!logFlag){ console.log = function(){}; }
      bypassForms(false,false); // allow user to skip consent and survey forms?
      var localSave = false; //save data button on fullscreen & code pages?
      if(!localSave){
        ['local-save-button-1','local-save-button-2'].forEach(function(btnName){
          document.getElementById(btnName).style.display = 'none';
        });
      }
      
      // IMPORTANT: Set to true before deploying
      // (if false, allows you to escape fullscreen before entering pointer lock,
      //  and then also to escape pointerlock if desired. can be helpful for debug.)
      var requireFullscreen = true;
      //var touchscreenDevice = false;
      
      var requireChrome = false; // limit to Chrome?
      var requireDesktop = true; // disallow mobile devices?
      
      // Initialize the 2d canvas
      var canvas = document.getElementById("2d-canvas");
      var canvasContext = canvas.getContext("2d");

      // Initialize trial and experiment objects
      var trialNumber = 0;
      var trial = {}; // trial object
      const exp = {
        renderMode: '2d',
        targetIds: [0,1,2,3,4], //linspace(0,25,26),
        targetDistance: 12,
        tooSlowDuration: 750,
        returnMethod: 'warp', // 'move', // 'warp'
        feedbackMode: 'terminal', // 'continuous', // 'terminal',
        requireTargetHit: true,
        maxTimePenalty: 3500,
        instructionsWaitDuration: 10, // time (seconds) until start button becomes enabled
        instructionsClickWaitTime: 1000, // time (msec) until a new click is accepted
      }; //experiment settings -- default to false & set to true/other below, by condition
      exp.yDirection = exp.renderMode=='3d' ? 1 : -1;
      exp.cursorSpeed = exp.renderMode=='3d' ? 0.025 : 1;
      exp.numObjects = exp.targetIds.length;
      exp.targetAngle0 = Math.random() * 2 * Math.PI / exp.numObjects;
      // to avoid math, make one extra target (at startAngle+2*pi) and pop it off
      exp.targetAngles = linspace(exp.targetAngle0, exp.targetAngle0 + 2 * Math.PI, exp.numObjects + 1);
      exp.targetAngles.pop();
      
      exp.condition = randomInteger(0,3); // CHOOSE THE CONDITION
      while (exp.condition==1){
        exp.condition = randomInteger(0,3); // CHOOSE THE CONDITION
      }
      /* If we got condition 0, repeat with 50% chance (bc we want twice as many in 2 & 3)
      if (exp.condition===0 && randomInteger(0,1)===1){
        exp.condition = randomInteger(0,3); // CHOOSE THE CONDITION
        while (exp.condition==1){
          exp.condition = randomInteger(0,3); // CHOOSE THE CONDITION
        }
      }*/

      switch (exp.condition){
        case 0:
          exp.perturbationType = 'rotation';
          exp.trainRepetitions = 0;
          exp.testRepetitions = 15;
          exp.outlierId = randomInteger(0,exp.targetIds.length-1);
          exp.globalRotation = 20 * Math.PI/180;
          exp.outlierRotation = 10 * Math.PI/180;
          exp.targetRotations = new Array(exp.targetIds.length).fill(exp.globalRotation);
          exp.targetRotations[exp.outlierId] = exp.outlierRotation;
          break;

        case 1:
          exp.perturbationType = 'gain';
          exp.trainRepetitions = 0;
          exp.testRepetitions = 15;
          exp.outlierId = randomInteger(0,exp.targetIds.length-1);
          exp.globalGain = 1.5;
          exp.outlierGain = 1.25;
          exp.targetGains = new Array(exp.targetIds.length).fill(exp.globalGain);
          exp.targetGains[exp.outlierId] = exp.outlierGain;
          exp.gainTargetSeparation = 0.3; // radians
          exp.gainTargetSpan = 2 * Math.PI / exp.numObjects - exp.gainTargetSeparation;
          exp.launchBall = true; // smooth cosine velocity to detected actual endpoint (long delay)
          //exp.flickBall = true; // smooth cosine velocity to inferred endpoint based on first 100 ms
          exp.stationaryTimeout = 100; // msec no movement after leaving home to terminate mousemove input
          break;

        case 2:
          exp.perturbationType = 'rotation';
          exp.trainRepetitions = 15;
          exp.testRepetitions = 0;
          exp.outlierId = randomInteger(0,exp.targetIds.length-1);
          exp.globalRotation = 20 * Math.PI/180;
          exp.outlierRotation = 20 * Math.PI/180; // unused
          exp.targetRotations = new Array(exp.targetIds.length).fill(exp.globalRotation);
          exp.targetRotations[exp.outlierId] = exp.outlierRotation;
          break;

        case 3:
          exp.perturbationType = 'rotation';
          exp.trainRepetitions = 0;
          exp.testRepetitions = 15;
          exp.outlierId = randomInteger(0,exp.targetIds.length-1);
          exp.globalRotation = 20 * Math.PI/180;
          exp.outlierRotation = -10 * Math.PI/180;
          exp.targetRotations = new Array(exp.targetIds.length).fill(exp.globalRotation);
          exp.targetRotations[exp.outlierId] = exp.outlierRotation;
          break;
      }
      
      var testTargetIds = [...exp.targetIds];
      var trainTargetIds = [...exp.targetIds];
      trainTargetIds.splice(exp.outlierId,1); // cut the middle one out

      // Construct the trial sequence
      var targetSequence = [];
      var blockSequence = [];
      for (let ri = 0; ri<exp.trainRepetitions; ri++){
        if (ri==0){
          shuffle(trainTargetIds);
        }else{
          // reshuffle until first trial of new block doesn't match last trial of previous
          while(targetSequence[ri-1][targetSequence[ri-1].length-1] === shuffle(trainTargetIds)[0]){}
        }
        blockSequence.push(new Array(trainTargetIds.length).fill(ri+1));
        targetSequence.push([...trainTargetIds]); // must assign a copy, not a reference!
      }
      for (let ri = exp.trainRepetitions; ri<exp.trainRepetitions+exp.testRepetitions; ri++){
        blockSequence.push(new Array(testTargetIds.length).fill(ri+1));
        targetSequence.push(exp.outlierId);
        shuffle(trainTargetIds);
        targetSequence.push([...trainTargetIds]); 
      }
      targetSequence = targetSequence.flat();
      blockSequence = blockSequence.flat();
      console.log(`Target sequence: ${targetSequence}`);
      const numTrials = targetSequence.length;

      // Declare our game objects
      const cursor = {};
      const home = {};
      const target = {};
      const occluder = {};

      switch (exp.renderMode){
        case '3d':
          // Initialize the 3d canvas
          var glCanvas = document.getElementById("3d-canvas");
          var gl = glCanvas.getContext("webgl2");
          initWebGL(gl, [0.05,0.05,0.05]);
          
          // Intialize shaders
          const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
          //const shadowShaderProgram = initShaderProgram(gl, shadowVsSource, shadowFsSource);
          
          // Initialize camera
          const camera = {};
          // gl, shader, position, focalPoint, near, far, fov
          initCamera(gl, shaderProgram, [0, 0, 60], [0, 0.001, 0], 40, 80, 45);
          
          // Initialize lighting (x, y, z, w)
          // w = 1 for point light, 0 for directional light
          // Remember to change '#define NR_LIGHTS' in the fragment shader if you add lights here
          const lightPositions = [[0, 0, 40, 0]];
          // If shadows, you must initCamera() first
          // For no shadows, simply omit the shadows argument of initLighting
          //const shadows = { lightIndex:0, textureUnit: 2, textureSize: 1024 };
          const light = initLighting(gl, shaderProgram, lightPositions, null, [0.5,0.5,0.1]);
          
          // Initialize textures
          // Be careful not to use the shadowMapTextureUnit assigned above!
          gl.activeTexture(gl.TEXTURE0); // default white (multiplies with material.diffuseColor)
          const defaultTexture = gl.createTexture();
          gl.bindTexture(gl.TEXTURE_2D, defaultTexture);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([255,255,255,255]));

          // Initialize game objects
          home = genDiskMesh(home);
          home.VAO = initVAO(gl,home,shaderProgram);
          instantiate(home);
          setModelParam(home, 'position', 0, [0, 0, 0.01]);
          setModelParam(home, 'orientation', 0, [0, 0, 0]);
          setModelParam(home, 'scale', 0, [3, 3, 1]);
          home.inactiveColor = [0.3, 0.3, 0.3];
          home.activeColor = [0.5, 0.1, 0.1];
          home.diffuseColor = [home.inactiveColor];
          home.radius = home.scale[0][0]/2;
          
          cursor = genIcosphereMesh(cursor, 1);
          cursor.VAO = initVAO(gl,cursor,shaderProgram);
          instantiate(cursor);
          setModelParam(cursor, 'position', 0, [0, 0, 0]);
          setModelParam(cursor, 'orientation', 0, [0, 0, 0]);
          setModelParam(cursor, 'scale', 0, [1,1,1]);
          cursor.activeColor = [0, 0.7, 0];
          cursor.inactiveColor = [0.7, 0, 0];
          cursor.diffuseColor = [cursor.inactiveColor];
          cursor.radius = cursor.scale[0][0]/2;
          cursor.positionH = [...cursor.position[0]];
          cursor.angle = 0;
          cursor.xmin = -20;
          cursor.xmax = 20;
          cursor.ymin = -20;
          cursor.ymax = 20;
          
          target.distance = exp.targetDistance;
          target = exp.perturbationType=='rotation' ? 
            genIcosphereMesh(target, 1) : exp.perturbationType=='gain' ? 
              genSpringMesh(target, exp.targetDistance, 1.5, 1, 20, true, exp.gainTargetSpan) : null;
          target.VAO = initVAO(gl,target,shaderProgram);
          for (let ti = 0; ti < exp.targetIds.length; ti++){
            instantiate(target);
            if (exp.perturbationType=='rotation'){
              // NB radialToEuclidean final param (ySign) == +1 (because in 3D the y axis is not flipped)
              var tmp = radialToEuclidean(exp.targetAngles[ti], exp.targetDistance, home.position[0], exp.yDirection);
              setModelParam(target, 'position', ti, [tmp[0], tmp[1], 0]);
              setModelParam(target, 'orientation', ti, [0, 0, 0]);
              setModelParam(target, 'scale', ti, [2, 2, 0.3]);
            }else if(exp.perturbationType=='gain'){
              setModelParam(target, 'position', ti, [0, 0, 0]);
              // NB orientation is shifted by -gainTargetSpan/2 to center on targetAngle (because springMesh go CCW in XY plane)
              setModelParam(target, 'orientation', ti, [0, 0, (exp.targetAngles[ti] - exp.gainTargetSpan/2)*180/Math.PI]);
              setModelParam(target, 'scale', ti, [1, 1, 0.3]);
            }
            computeModelMatrix(target,ti); // need to do this so we can draw the explosion in first trial
          }
          target.inactiveColor = [0.3, 0.3, 0.3];
          target.activeColor = [1.0, 0, 0];
          target.hitColor = [0, 1.0, 0];
          target.diffuseColor = new Array(exp.targetIds.length).fill(target.inactiveColor);
          target.radius = target.wireRadius ? target.wireRadius : target.scale[0][0]/2;

          var occluderRadius = 0.95*(exp.targetDistance-target.radius);
          occluder = genDiskMesh(occluder, 40,1.2*cursor.radius/occluderRadius);
          occluder.outerRadius = occluderRadius;
          occluder.VAO = initVAO(gl,occluder,shaderProgram);
          instantiate(occluder);
          setModelParam(occluder, 'position', 0, [0, 0, 1.1*cursor.scale[0][2]/2].flat());
          setModelParam(occluder, 'orientation', 0, [0, 0, 0]);
          setModelParam(occluder, 'scale', 0, [occluderRadius*2, occluderRadius*2, 1]);
          occluder.diffuseColor = [[0.10,0.05,0.17]];
          
          /*floor = genQuadMesh(floor);
          floor.VAO = initVAO(gl,floor,shaderProgram);
          instantiate(floor);
          setModelParam(floor, 'position', 0, [0, 0, 0]);
          setModelParam(floor, 'orientation', 0, [-Math.PI/2, 0, 0]);
          setModelParam(floor, 'scale', 0, [50, 1, 30]);
          floor.diffuseColor = [[0, 0.7, 0]];*/
          break;

        case '2d':
          exp.homePosition = [0.5, 0.5]; // proportions of canvas width and height
          exp.targetDistance = 0.3; // proportion of canvas height
          exp.targetRadiusAngle = 5*Math.PI/180; // radius in degree span

          // Initialize game objects
          home.position = [[0, 0]];
          home.inactiveColor = [0.3, 0.3, 0.3];
          home.activeColor = [0.5, 0.1, 0.1];
          home.diffuseColor = [home.inactiveColor];
          home.radius = 20;
          
          cursor.position = [[0, 0]];
          cursor.activeColor = [0, 0.7, 0];
          cursor.inactiveColor = [0.7, 0, 0];
          cursor.diffuseColor = [cursor.inactiveColor];
          cursor.radius = 5;
          cursor.positionH = [...cursor.position[0]];
          cursor.angle = 0;
          cursor.xmin = 0;
          cursor.xmax = canvas.width;
          cursor.ymin = 1;
          cursor.ymax = canvas.height-60;
          
          target.position = [];
          target.distance = exp.targetDistance * canvas.height;
          for (let ti = 0; ti < exp.targetIds.length; ti++){
            // NB radialToEuclidean final param (ySign) is left out
            var tmp = radialToEuclidean(exp.targetAngles[ti], target.distance, home.position[0], exp.yDirection);
            target.position.push(tmp);
          }
          target.inactiveColor = [0.3, 0.3, 0.3, 1];
          target.activeColor = [1.0, 0, 0, 1];
          target.hitColor = [0, 1.0, 0, 1];
          target.diffuseColor = new Array(exp.targetIds.length).fill(target.inactiveColor);
          target.radius = Math.tan(exp.targetRadiusAngle)*target.distance;
          cursor.radius = target.radius/4;
          home.radius = target.radius;

          occluder.position = [[0, 0]];
          occluder.outerRadius = target.distance-0.75*target.radius;
          occluder.diffuseColor = [[0.10,0.05,0.17,0.5]];

          break;
      }
      
      if (exp.perturbationType=='gain'){
        cursor.stationaryTimer = new Timer();
        cursor.stationaryTimeout = exp.stationaryTimeout;
        if (exp.launchBall){
          cursor.launchTimer = new Timer();
        }
      }

      // Initialize finite state machine
      const stateNames = ['PAUSE', 'START', 'GO', 'MOVING', 'CORRECT', 'LAUNCH', 'RETURN', 'FINISH', 'ADVANCE', 'FULLSCREEN', 'CONNECTION'];
      var state = new State(stateNames, handleStateChange);

      // Initialize anything else that is used before initTrial() is called
      var points = {total: 0, earned: undefined, text: currencyFormatter.format(0)};
      var feedback = {text: '', correctColor: [0,255,0,1], incorrectColor: [255,0,0,1], size: 18}; // colors for 2d canvas are 0-255
      feedback.color = [...feedback.correctColor];
      var instructions = {text: '', lines: [], position: [], size: 14, color: 'black'};
      var numClicks = 0;

      setInterval(setFPS, 1000);
      exp.FPS = {};
      function setFPS(){
        exp.FPS.text = exp.FPS.frames;
        exp.FPS.frames = 0;
      }
      
      addEventListeners();
      mainLoopFunc(); // requires calcFunc(), stateFunc(), and displayFunc() to be defined

      function initTrial(trialNumber) {
        trial = {
          // static params
          condition: exp.condition,
          // dynamic params
          trialNumber: trialNumber,
          targetId: targetSequence[trialNumber],
          block: blockSequence[trialNumber],
          startTime: performance.now(),
          demoTrial: trialNumber===0,
          ITI: randomInteger(100,250),
          // reset params
          distanceTraveled: 0,
          missTrial: false,
          missTrialMsg: '',
          rotation: 0, // default
          gain: 1, // default
          // reset data arrays
          x: [],
          y: [],
          tFrame: [],
          stateFrame: [],
          dx: [],
          dy: [],
          t: [],
          state: [],
          dxCo: [],
          dyCo: [],
          tCo: [],
          stateCo: [],
          stateChange: [],
          stateChangeTime: [],
        };
        // dynamic params dependent on params set in the object constructor
        // (could assign these in the object constructor but this is often easier)
        trial.targetAngle = exp.targetAngles[trial.targetId];
        
        // apply any condition-specific parameters/settings
        // (could do this outside of initTrial if they are not trial-specific)
        switch (exp.perturbationType){
          case 'rotation':
            trial.rotation = exp.targetRotations[trial.targetId];
            break;

          case 'gain':
            trial.gain = exp.targetGains[trial.targetId];
            break;
        }
        
        // reset parameters of game objects
        cursor.delta = [0, 0];
        cursor.cross = [null, null];
        cursor.hit = false;
        cursor.corrected = false;
        cursor.tooSlow = false;
        cursor.disableMovement = true;
        cursor.movementComplete = false;
        //cursor.flickComplete = false;
        cursor.launchComplete = false;
        cursor.updateDisplayRealTime = !exp.launchBall;
        cursor.lastEvent = undefined;
        
        if (exp.returnMethod=='warp'){
          if (exp.renderMode=='3d'){
            setModelParam(cursor, 'position', 0, [...home.position[0]]);
          }else if(exp.renderMode=='2d'){
            cursor.position[0] = [...home.position[0]];
          }
        }
        cursor.positionH = [...cursor.position[0]];
        cursor.prevDisplay = [...cursor.position[0]];
        //setDisplayedCursorPosition();

        target.diffuseColor = new Array(exp.targetIds.length).fill(target.inactiveColor);

        if (exp.renderMode=='3d'){
          target.centerPx = getObjectPixelCoords([0,0,0], target.modelMatrix[trial.targetId]);
          target.edgePx = getObjectPixelCoords([0.5,0,0],target.modelMatrix[trial.targetId]);
          target.radiusPx = target.edgePx[0]-target.centerPx[0];
          if (exp.perturbationType=='rotation'){
            target.explosion = new Explosion(target.centerPx, target.radiusPx, target.activeColor, 400, 20, 13, 0.3);
          }
        }else if (exp.renderMode=='2d'){
          if (exp.perturbationType=='rotation'){
            target.explosion = new Explosion(target.position[trial.targetId], target.radius, target.activeColor, 400, 20, target.radius/2, target.radius/40);
          }
          occluder.diffuseColor[0][3] = 0.5 + Math.min(0.5,0.5*(trial.trialNumber/8));          
        }

        points.earned = undefined;
        instructions.text = '';
        //feedback.text = '';
        alphaFade(feedback,null,0.05);
        
        saveSuccessful = false;
        trialTimer.reset();
        state.next(state.START);
      }

      function calcFunc(timestamp) {
        if (Object.keys(trial).length === 0) { return; }

        updateCursor(timestamp, cursor.lastEvent);

        cursor.speed = distance(cursor.delta, [0, 0]); // compute speed
        //trial.distanceTraveled += cursor.speed * exp.cursorSpeed * trial.gain; // accumulate distanceTraveled
        cursor.delta = [0, 0]; // reset delta to zero (critical!)

        // Test if the cursor is at home
        //if (state.current==state.GO || exp.returnMethod=='move'){
        cursor.atHome = isHome(cursor.positionH, home.position[0], home.radius - cursor.radius) && cursor.speed < 10;
        //}
        
        /* Make the target sink into the ground
        if ((state.current===state.MOVING && !cursor.tooSlow) || 
            (state.current===state.RETURN && !cursor.hit)){
          target.position[trial.targetId][2] -= 0.95*dt*target.scale[trial.targetId][2]/exp.tooSlowDuration;
        }*/
      }

      function stateFunc() {
        if (!requireFullscreen){
          FS = true;
          PL = true;
        }
        
        // Check firebase, fullscreen, and pointer lock (unless in a state where they can be off)
        if (!isMember(state.current, [state.CONNECTION, state.FULLSCREEN, state.PAUSE])) {
          if (!FB){ // firebase connection flag
            cursor.disableMovement = true;
            state.push(state.CONNECTION);
          }else if (!FS || !PL) { // fullscreen and pointer lock flags
            cursor.disableMovement = true;
            state.push(state.FULLSCREEN); // pushing the state effectively 'saves' the current state
          }
        }

        switch (state.current) {
          case state.START:
            if (!cursor.disableMovement){// && cursor.atHome) {
              target.diffuseColor[trial.targetId] = [...target.activeColor];
              state.next(state.GO); // advance
            }
            break;

          /*case state.DELAY:
            if (!cursor.atHome){
              state.next(state.START); // go back
            }else if ((!trial.demoTrial && state.expiredMSec(250)) || state.expiredMSec(1200)) {
              state.next(state.GO); // advance
            }
            break;
          */

          case state.GO:
            if (!cursor.atHome) {
              state.next(state.MOVING); // advance
            }
            break;

          case state.MOVING:
            if (!cursor.tooSlow && state.expiredMSec(exp.tooSlowDuration) && !trial.demoTrial) {
              cursor.tooSlow = true;
            }
            switch (exp.perturbationType){
              case 'gain':
                if (cursor.tooSlow){ // force stop the initial movement if timeout (gain condition only)
                  cursor.movementComplete = true;
                } else if (cursor.speed > 0) { // if moving and not timeout, keep resetting
                  cursor.stationaryTimer.reset();
                } else if (cursor.stationaryTimer.elapsedMSec() > cursor.stationaryTimeout){ // if stationary timeout, stop the movement
                  cursor.movementComplete = true;
                  cursor.hit = cursorHitGainTarget(); // record if it was a hit
                }
                break;

              case 'rotation':
                if (!cursor.tooSlow && distance(cursor.cross, target.position[trial.targetId]) < (target.radius + cursor.radius)) {
                  cursor.hit = true;
                }
                break;
            }
            if (cursor.movementComplete) { // *required* movement is complete
              if (exp.launchBall){
                planLaunchMovement(1,500);
                state.next(state.LAUNCH);
                break;
              }else{
                setTrialFeedback();
                if (!cursor.hit && exp.requireTargetHit){
                  if(trial.trialNumber>=8){
                    alphaFade(occluder,0,0.01,0.8);
                  }
                  state.next(state.CORRECT);
                }else{
                  if (exp.returnMethod=='warp'){ cursor.disableMovement = true; }
                  state.next(state.RETURN);
                }
              }
            }
            break;

          case state.CORRECT:
            if (cursor.speed < 5 &&
                ((exp.perturbationType=='gain' && cursorHitGainTarget()) ||
                 (exp.perturbationType=='rotation' && cursor.distanceToTarget < (target.radius + cursor.radius)))) {
              if (exp.returnMethod=='warp'){ cursor.disableMovement = true; }
              if (exp.renderMode=='2d'){
                alphaFade(target,trial.targetId);
              }else{
                target.diffuseColor[trial.targetId] = [...target.inactiveColor];
              }
              if (feedback.text.includes('go to the target')){
                feedback.text = feedback.text.slice(0,feedback.text.search('\n'))
              }
              state.next(state.RETURN);
            }
            break;

          case state.LAUNCH:
            cursor.launchComplete = executeLaunchMovement();
            if (cursor.launchComplete) {
              setTrialFeedback();
              if (exp.returnMethod=='warp'){ cursor.disableMovement = true; }
              state.next(state.RETURN); // advance
            }
            break;

          case state.RETURN:
            if ((exp.returnMethod=='warp' && state.expiredMSec(400+trial.demoTrial*600)) || 
                (exp.returnMethod=='move' && cursor.atHome)) {
              state.next(state.FINISH); // advance
            }
            break;

          case state.FINISH:
            if ((trial.demoTrial && (!state.expiredMSec(Math.max(1000,trial.timePenalty)) || state.numClicks<1)) ||
                (!trial.demoTrial && !state.expiredMSec(trial.timePenalty))) {
              break;
            }
            // make sure all the data we need is in the trial object
            trial.hit = cursor.hit;
            trial.tooSlow = cursor.tooSlow;
            trial.cross = [...cursor.cross];
            trial.crossAngle = cursor.crossAngle;
            trial.target = [...target.position[trial.targetId]];
            trial.canvas = [canvas.width, canvas.height];
            trial.points = points.total;
            // save the trial object, set flag in succesful callback
            firebaseTrialSave(trial, function() {
              saveSuccessful = true;
            });
            state.next(state.ADVANCE);
            break;

          case state.ADVANCE:
            if (!saveSuccessful && !state.expiredMSec(trial.ITI)) {
              // don't do anything until firebase save returns successful
              break;
            }
            trialNumber++;
            document.getElementById('progressbar-inner').style.width = 100 * (trialNumber) / numTrials + '%';
            if (trialNumber < numTrials) {
              if (exp.renderMode=='3d'){
                setModelParam(target, 'scale', trial.targetId, target.scale[trial.targetId][0], 1);
              }
              initTrial(trialNumber);
            } else {
              state.next(state.PAUSE);
              firebaseExperimentComplete(function(){
                experimentFinished = true;
                wjsExitFullscreen(document);
                document.getElementById('code-text').value = generateCompletionCode();
                document.getElementById('trial-content').style.display = 'none';
                document.getElementById('code-content').style.display = 'block';
                document.getElementById('bonus-text').innerHTML = 'Thank you for your help! You earned a bonus of ' + points.text + '.';
              });
            }
            break;

          case state.FULLSCREEN:
            if (FS && PL) {
              state.pop();
              if (state.current > state.START && (exp.returnMethod!=='warp' || state.current<state.RETURN))
                cursor.disableMovement = false;
              dtTimer.reset();
            }
            break;
            
          case state.CONNECTION:
            if (FB) {
              state.pop();
              if (state.current > state.START && (exp.returnMethod!=='warp' || state.current<state.RETURN))
                cursor.disableMovement = false;
              dtTimer.reset();
            }
            break;
        }
      }

      function displayFunc() {
        // nothing to draw in these states
        if (state.current < state.START || state.current > state.ADVANCE) { return; }
        
        /* Draw the shadow map
        if (light.shadowsOn){
          gl.bindFramebuffer(gl.FRAMEBUFFER, light.shadowMapFBO);
          gl.viewport(0, 0, shadows.textureSize, shadows.textureSize);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
          if (state.current >= state.GO && state.current <= state.RETURN) {
            drawObjectShadowMap(gl, shadowShaderProgram, target, light.viewProjection);
          }
          drawObjectShadowMap(gl, shadowShaderProgram, cursor, light.viewProjection);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        }*/
        
        canvasContext.clearRect(0, 0, canvas.width, canvas.height); // Clear 2d canvas
        // Set home position color to signal atHome      
        //home.diffuseColor[0] = cursor.atHome ? home.activeColor : home.inactiveColor;
        
        // Set cursor color to signal whether activated
        cursor.diffuseColor[0] = (cursor.disableMovement && !cursor.hit) ? cursor.inactiveColor : cursor.activeColor;

        if(exp.renderMode=='2d'){
          // Draw home position
          drawCircle(home.position[0], home.radius, home.diffuseColor[0], true, 2);
          // Draw inactive targets
          for (let ti = 0; ti < exp.targetIds.length; ti++){
            drawCircle(target.position[ti], target.radius, target.inactiveColor, false, 1);
          }
          // Draw target
          if (state.current >= state.MOVING && cursor.hit) {
            target.explosion.draw();
          } else if (state.current >= state.GO) {
            drawCircle(target.position[trial.targetId], target.radius, target.diffuseColor[trial.targetId], true, 2);
          }
          if (state.current > state.MOVING) {
            drawCircle(cursor.cross, cursor.radius, cursor.inactiveColor, false, 1.5);
          }
          // Draw cursor
          drawCircle(cursor.position[0], cursor.radius, cursor.diffuseColor[0], true, 2);
          // Draw occluder
          drawCircle(occluder.position[0], (occluder.outerRadius+home.radius)/2, occluder.diffuseColor[0], false, occluder.outerRadius-home.radius)

        }else if (exp.renderMode=='3d'){
          gl.viewport(0, 0, glCanvas.width, glCanvas.height);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT); // Clear WebGL canvas

          // Draw 3d objects
          //drawObject(gl, shaderProgram, home);
          if (!(state.current==state.MOVING && exp.perturbationType=='gain' && !exp.launchBall)){
            drawObject(gl, shaderProgram, cursor);
          }
          //drawObject(gl, shaderProgram, floor);
          drawObject(gl, shaderProgram, target);
          if (exp.perturbationType=='rotation' && exp.feedbackMode=='terminal'){
            drawObject(gl,shaderProgram, occluder);
          }
          if (state.current >= state.MOVING && cursor.hit && target.explosion) {
            target.explosion.draw();
            drawCircle(target.centerPx,target.radiusPx,target.activeColor.map(x=>x*128),false,2.5);
          }
        }

        if (state.current===state.FINISH && trial.timePenalty > exp.maxTimePenalty/4){
          let p = (trial.timePenalty-state.elapsedMSec())/exp.maxTimePenalty;
          drawCircle([canvas.width / 2, canvas.height / 2], 20, [180,0,0], false, 3, p, Math.PI/2);
        }

        // draw trial text (feedback, score, instructions, etc)
        setTrialText();
        drawText(instructions.position, instructions.text, instructions.size, instructions.color);
        drawText([canvas.width/12, 50], 'Your Score: ' + points.total + '\nBonus: ' + points.text, 16, points.color, 'left');
        drawText([canvas.width/2, canvas.height/2 - canvas.height*.15], feedback.text, feedback.size, feedback.color);
        if (trial.demoTrial && state.current == state.FINISH && state.expiredMSec(Math.max(1000,trial.timePenalty))){
          drawText([canvas.width/2, 16],'(Click to end the demo trial)',14,'rgb(45,90,255)');
        }
        if (!trial.demoTrial && trial.trialNumber<8){
          drawText([canvas.width/2, 16],'(The purple disk is becoming harder to see through.)',14,'rgb(110,55,190)');
        }else if (!trial.demoTrial && trial.trialNumber<12){
          drawText([canvas.width/2, 16],'(The purple disk is now completely opaque.)',14,'rgb(110,55,190)');
        }

        drawText([canvas.width-50, canvas.height-50], 'FPS:' + exp.FPS.text, 14, 'white')
        exp.FPS.frames++;
      }

      function setTrialFeedback() {
        // In either case (hit or miss)
        switch (exp.perturbationType){
          case 'rotation':
            // compute trial error (radians)
            trial.error = cursor.crossAngle - trial.targetAngle;
            if (Math.abs(trial.error) > Math.PI){
              let d1 = trial.error - 2*Math.PI;
              let d2 = trial.error + 2*Math.PI;
              let sgnErrors = [trial.error,d1,d2];
              let absErrors = sgnErrors.map(x => Math.abs(x));
              let ix = absErrors.indexOf(Math.min(...absErrors));
              if (ix===-1) { console.error('WJS-ERROR: Failed to compute trial error!'); }
              trial.error = sgnErrors[ix];
            }
            
            trial.timePenalty = Math.min(exp.maxTimePenalty,Math.pow(trial.error*1.6*180/Math.PI,2));
            console.log('WJS: Error = ' + round(trial.error*180/Math.PI,1) + ' degrees, time penalty = ' + round(trial.timePenalty,1) + 'msec');
            break;

          case 'gain':
            trial.error = cursor.distanceToHome-target.distance;
            trial.timePenalty = cursorInGainRegion() ? Math.min(exp.maxTimePenalty,Math.pow(trial.error*5,2)) : exp.maxTimePenalty;
            console.log('WJS: Error = ' + round(trial.error,1) + ' cm, time penalty = ' + round(trial.timePenalty,1) + 'msec');
            break;

        }
        if (cursor.tooSlow){
          trial.timePenalty = Math.max(exp.maxTimePenalty/2, trial.timePenalty);
          console.log('WJS: Too slow! Time penalty = ' + round(trial.timePenalty,1) + 'msec');
        }
        if (Number.isNaN(trial.timePenalty)) {
          trial.timePenalty = 0;
        }

        if (cursor.hit && !cursor.tooSlow) { // if we hit
          switch (exp.perturbationType){
            case 'rotation':
              if (exp.renderMode=='3d'){
                setModelParam(target, 'scale', trial.targetId, 0, 1);
              }
              //computeModelMatrix(cursor);
              //target.explosion.position = getObjectPixelCoords([0,0,0], cursor.modelMatrix[0]);
              target.explosion.fragmentSize *= 1/(1+Math.abs(trial.error*28));
              target.explosion.speed *= 1/(1+Math.abs(trial.error*14));
              //console.log('WJS: explosin speed = ' + target.explosion.speed);
              target.explosion.pop();
              break;

            case 'gain':
              target.diffuseColor[trial.targetId] = [...target.hitColor];
              break;
          }
          points.earned = 2;
          clearInterval(feedback.fadeRoutine);
          feedback.text = '+' + points.earned + '¢';
          //points.color = [0, 180, 0];
          //colorFade(points, [255, 255, 255], 0.05);
          feedback.color = [...feedback.correctColor];

        } else { // if we missed
          points.earned = 0;
          clearInterval(feedback.fadeRoutine);
          feedback.text = cursor.tooSlow ? 'too slow' : 'miss';
          if (!exp.requireTargetHit){
            if (exp.renderMode=='2d'){
              alphaFade(target,trial.targetId);
            }else{
              target.diffuseColor[trial.targetId] = [...target.inactiveColor];
            }
          }else{
            feedback.text += '\ngo to the target'
          }
          feedback.color = [...feedback.incorrectColor];
        }
        
        // Set the points
        points.total += points.earned;
        points.text = currencyFormatter.format(points.total / 100);
      }

      function setTrialText() {
        if (trial.demoTrial) {
          if (!state.expiredMSec(200) && state.current !== state.MOVING) {
            instructions.text = ''; // clear text at start of every state, to make change more obvious
          } else {
            switch (state.current){
              case state.START:
                instructions.text = 'Click the mouse to activate the cursor.';
                /*if (exp.condition==1){
                  instructions.text += '\nYour goal is to launch the ball so it lands INSIDE the red target zone!';
                }*/
                break;

              case state.DELAY:
                //instructions.text = 'Wait for the target to light up...';
                //break;

              case state.GO:
              case state.MOVING:
                if (exp.perturbationType=='rotation') {
                  instructions.text = 'Now move the green cursor to hit the red target!';
                  instructions.text += '\nPlease make a quick, uninterrupted swipe in the correct direction.';
                  instructions.text += '\nThe purple occlusion disk hides the cursor while it is moving.';
                }else if (exp.perturbationType=='gain'){
                  //instructions.text = 'Launch the ball so it lands INSIDE the red target zone!';
                  instructions.text = 'Now launch the green cursor so it lands INSIDE the red target zone.';
                  instructions.text += '\nPlease make a quick, uninterrupted swipe in the correct direction.';
                  instructions.text += '\nAdjust the strength of your swipe to get the cursor in the target.';
                }
                break;

              case state.RETURN:
                if (cursor.hit) {
                  instructions.text = 'Nice job!'
                } else {
                  instructions.text = 'You missed!'
                }
                if (exp.returnMethod=='move'){
                  instructions.text += '\nNow return to the center.'
                }
                break;

              case state.FINISH:
                instructions.text = 'That was one trial.\n'+
                  'There are '+numTrials+' trials in total.\n'+
                  'Please try to finish without taking a break.';
                break;
            } 
          }
        }else{
          switch (state.current) {
            case state.START:
              instructions.text = '';
              if (cursor.disableMovement && state.expiredMSec(1000)) {
                instructions.text = 'Click the mouse to activate the cursor.';
              }
              break;

            case state.GO:
            case state.MOVING:
              if (state.current==state.GO){
                instructions.text = '';
                if (state.expiredMSec(1000)) {
                  if (exp.perturbationType=='rotation') {
                    instructions.text = 'Now move the green cursor to hit the red target!';
                    instructions.text += '\nTry to make a quick, straight movement (a \'swipe\').';
                    instructions.text += '\nThe purple disk hides the cursor while it is moving.';
                  }else if (exp.perturbationType=='gain'){
                    //instructions.text = 'Launch the ball so it lands INSIDE the red target zone!';
                    instructions.text = 'Now launch the cursor so it lands INSIDE the red target zone.';
                    instructions.text += '\nLaunch the cursor by making a short, uninterrupted swipe in the correct direction.';
                    instructions.text += '\nAdjust the strength of your swipe to get the cursor in the target.';
                  }
                }
              }
              break;

            case state.RETURN:
              instructions.text = '';
              if (exp.returnMethod=='move' && !cursor.atHome && state.expiredMSec(1000)) {
                instructions.text = 'Return to the center.';
              }
              break;
          }
        }
        instructions.position = [canvas.width/2, canvas.height/10];
        instructions.size = 16;
        instructions.color = 'white';
      }

      function addEventListeners() {
        // ONLOAD
        window.addEventListener('DOMContentLoaded', browserCheck);
        
        // CONSENT
        document.getElementById('consent-form').addEventListener('submit', function(event) {
          event.preventDefault(); // prevent the default form submission
          document.getElementById('consent-content').style.display = 'none';
          document.getElementById('survey-content').style.display = 'block';
          firebaseSignIn(function() {
            document.getElementById('survey-button').removeAttribute('disabled')
          });
        });
        
        // SURVEY
        document.getElementById('survey-form').addEventListener('submit', function(event) {
          event.preventDefault();
          var data = new FormData(event.target);
          var surveydata = Object.fromEntries(data.entries());
          surveydata.date = getFormattedDateObject();
          surveydata.browser = browserInfo.browser;
          surveydata.os = browserInfo.os;
          surveydata.trialNumber = 'info';
          surveydata.stateNames = stateNames;
          workerId = surveydata.workerId;
          // experiment-specific:
          surveydata.experimentSettings = exp;
          document.getElementById('survey-button').setAttribute('disabled','');
          firebaseTrialSave(surveydata, function() {
            document.getElementById('survey-content').style.display = 'none';
            document.getElementById('instructions-content').style.display = 'block';
            document.getElementById('instructions-button').innerHTML = 'Start (' + exp.instructionsWaitDuration + ')';
            exp.instructionsTimerRoutine = setInterval(function(){
              exp.instructionsWaitDuration -= 1;
              if (exp.instructionsWaitDuration===0){
                document.getElementById('instructions-button').innerHTML = 'Start';
                document.getElementById('instructions-button').removeAttribute('disabled');
                clearInterval(exp.instructionsTimerRoutine);
              }else{
                document.getElementById('instructions-button').innerHTML = 'Start (' + exp.instructionsWaitDuration + ')';
              }
            }, 1000);
          });
        });

        // INSTRUCTIONS
        document.getElementById('instructions-button').addEventListener('click', function(event) {
          initTrial(trialNumber); // this should be the first call to initTrial
          document.getElementById('instructions-content').style.display = 'none';
          document.getElementById('fullscreen-content').style.display = 'block';
        });

        // FULLSCREEN
        document.getElementById('fullscreen-button').addEventListener('click', function(event) {
          wjsRequestFullscreen(document.body); // custom function that supports Safari
        });
        
        // POINTER LOCK
        document.getElementById('pointerlock-button').addEventListener('click', function(event) {
          document.body.requestPointerLock();
          //initCursor(event)
        });
        
        // LOCAL SAVE
        ['local-save-button-1','local-save-button-2'].forEach(function(btnName){
          document.getElementById(btnName).addEventListener('click', function(event) {
            firebaseLocalSave();
          });
        });

        // COPY CODE TO CLIPBOARD
        document.getElementById('code-button').addEventListener('click', function() {
          var copyText = document.getElementById('code-text');
          copyText.select(); // select the text field
          copyText.setSelectionRange(0, 99999); // ...for mobile devices?
          document.execCommand('copy'); // copy the selected text
          document.getElementById('code-button').setAttribute('disabled', '');
          alert('Completion code copied to clipboard.')
        });
        
        // FULLSCREEN
        ['fullscreenchange', 'webkitfullscreenchange'].forEach(function(eventName){
          document.addEventListener(eventName, (event) => {
            var fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement;
            if (fullscreenElement) {
              console.log(`Entering full-screen mode on ${fullscreenElement}.`);
              document.getElementById('fullscreen-content').style.display = 'none';
              document.getElementById('pointerlock-content').style.display = 'block';
              updateCanvas();
              FS = true;
            } else {
              console.log('Exiting full-screen mode.');
              if(state.current!==state.PAUSE && requireFullscreen){
                document.getElementById('trial-content').style.display = 'none';
                document.getElementById('pointerlock-content').style.display = 'none';
                document.getElementById('fullscreen-content').style.display = 'block';
                trial.missTrial = true;
                trial.missTrialMsg = 'pointerlockDisabled';
              }
              FS = false;
            }
          });
        });

        // POINTER LOCK
        document.addEventListener('pointerlockchange', (event) => {
          if (document.pointerLockElement) {
            console.log(`Entering pointer lock on ${document.pointerLockElement.id}.`);
            document.getElementById('pointerlock-content').style.display = 'none';
            document.getElementById('trial-content').style.display = 'block';
            PL = true;
          } else {
            console.log('Exiting pointer lock.');
            var fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement;
            if (fullscreenElement) { 
              wjsExitFullscreen(document);
            }else if (state.current!==state.PAUSE && requireFullscreen){
              document.getElementById('trial-content').style.display = 'none';
              document.getElementById('pointerlock-content').style.display = 'none';
              document.getElementById('fullscreen-content').style.display = 'block';
              trial.missTrial = true;
              trial.missTrialMsg = 'pointerlockDisabled';
            }
            PL = false;
          }
        }, false);
        
        document.addEventListener('pointerlockerror', (event) => {
          alert('Error: Pointer lock request failed!');
        }, false);

        // MOUSE
        document.body.addEventListener('mousemove', handleMouseMove);
        document.body.addEventListener('click', handleClick);
        document.body.addEventListener('pointermove', handlePointerMove);

        // RESIZE
        window.addEventListener('resize', handleResize);
        
        // PAGE CLOSE ALERT
        window.addEventListener('beforeunload', function(){
          if(!experimentFinished){
            return event.returnValue = 'Are you sure you want to quit?';
          }
        });
        
        // FIREBASE DISCONNECT
        firebase.database().ref().child('.info/connected').on('value', function(connectedSnap) {
          if (connectedSnap.val() === true) {
            document.getElementById('page-content').style.display = 'block';
            document.getElementById('connection-content').style.display = 'none';
            FB = true;
          } else {
            document.getElementById('page-content').style.display = 'none';
            document.getElementById('connection-content').style.display = 'block';
            FB = false;
          }
        });
      }

      function handleStateChange() {
        state.numClicks = 0;
        clickTimer.reset();
        trial.stateChange.push(state.current);
        trial.stateChangeTime.push(performance.now());
      }

      function handleResize(event) {
        //if (state.current >= state.START && state.current <= state.ADVANCE) {
        updateCanvas();
        
        if (exp.renderMode=='3d') {
          if (Object.keys(trial).length !== 0){
            target.centerPx = getObjectPixelCoords([0,0,0], target.modelMatrix[trial.targetId]);
            target.edgePx = getObjectPixelCoords([0.5,0,0],target.modelMatrix[trial.targetId]);
            target.radiusPx = target.edgePx[0]-target.centerPx[0];
            if (target.explosion) { target.explosion = new Explosion(target.centerPx, target.radiusPx, target.activeColor, 400, 20, 13, 0.3); }
          }

        }else if (exp.renderMode=='2d') {
          cursor.xmax = canvas.width;
          cursor.ymax = canvas.height-60;
          home.position[0] = [exp.homePosition[0] * canvas.width, exp.homePosition[1] * canvas.height];
          cursor.position[0] = [...home.position[0]];
          cursor.positionH = [...cursor.position[0]];
          occluder.position[0] = [...home.position[0]];
          target.distance = exp.targetDistance * canvas.height;
          target.radius = Math.tan(exp.targetRadiusAngle)*target.distance;
          cursor.radius = target.radius/4;
          home.radius = target.radius;
          occluder.outerRadius = target.distance-0.75*target.radius;//0.95*(target.distance-target.radius);
          for (let ti = 0; ti < exp.targetIds.length; ti++){
            target.position[ti] = radialToEuclidean(exp.targetAngles[ti], target.distance, home.position[0], exp.yDirection);
          }
          target.explosion = new Explosion(target.position[trial.targetId], target.radius, target.activeColor, 400, 20, target.radius/2, target.radius/40);
        }
      }

      function handleMouseMove(event) {
        if ((!document.pointerLockElement && requireFullscreen) || 
            (trial.tPrev === event.timeStamp) ||
            Object.keys(trial).length === 0) {
          return;
        }
        
        if (state.current >= state.START && state.current <= state.FINISH) {
          cursor.lastEvent = event;
          trial.t.push(event.timeStamp);
          trial.dx.push(event.movementX);
          trial.dy.push(-event.movementY);
          trial.state.push(state.current);
          trial.tPrev = event.timeStamp; // Safari double-firing bug workaround
        }
      }
      
      function updateCursor(frametime, event){
        // move the cursor
        if (event && isMember(state.current, [state.GO, state.MOVING, state.CORRECT, state.RETURN]) &&
            !cursor.disableMovement) {

          // set deltas ONLY if we are not already at an edge
          var clampedX = [cursor.xmin, cursor.xmax].indexOf(cursor.position[0][0]);
          var clampedY = [cursor.ymin, cursor.ymax].indexOf(cursor.position[0][1]);
          if ((clampedX === -1) || 
              (clampedX === 0 && event.movementX >= 0) || 
              (clampedX === 1 && event.movementX <= 0)){
            cursor.delta[0] = event.movementX;
          }
          if ((clampedY === -1) || 
              (clampedY === 0 && -exp.yDirection*event.movementY >= 0) || 
              (clampedY === 1 && -exp.yDirection*event.movementY <= 0)){
            cursor.delta[1] = -exp.yDirection*event.movementY; // event.movementY is inverted, so we "undo" the y direction
          }

          //consoleLog('WJS: '+cursor.delta);
          // update the "haptic position"
          // TODO: should this really include the gain perturbation??
          cursor.positionH[0] += cursor.delta[0] * exp.cursorSpeed * trial.gain;
          cursor.positionH[1] += cursor.delta[1] * exp.cursorSpeed * trial.gain;
        
          // transform from cursor.positionH to cursor.position[0]
          setDisplayedCursorPosition();
          //consoleLog('WJS: '+cursor.position[0]);

          // condition-independent calculations
          cursor.distanceToHome = distance(cursor.positionH, home.position[0]);
          let ca = Math.atan2(exp.yDirection*(cursor.positionH[1]-home.position[0][1]),cursor.positionH[0]-home.position[0][1]);
          cursor.angle = (ca > 0 ? ca : (2*Math.PI + ca));
          
          // condition-dependent calculations
          switch (exp.perturbationType){
            case 'gain':
              cursor.distanceToTarget = Math.abs(cursor.distanceToHome-target.distance);
              break;

            case 'rotation':
              cursor.distanceToTarget = distance(cursor.position[0], target.position[trial.targetId]);
              // compute where the cursor passed through the circle containing the target
              // https://stackoverflow.com/questions/1073336/
              if (state.current === state.MOVING && 
                  cursor.distanceToHome > target.distance && 
                  !cursor.movementComplete) {
                var r = target.distance;//distance(target.position[trial.targetId], home.position[0]); // radius of target-containing circle
                var d = [cursor.position[0][0] - cursor.prevDisplay[0], cursor.position[0][1] - cursor.prevDisplay[1]];
                var f = [cursor.prevDisplay[0] - home.position[0][0], cursor.prevDisplay[1] - home.position[0][1]];
                var a = d[0] * d[0] + d[1] * d[1];
                var b = 2 * (f[0] * d[0] + f[1] * d[1]);
                var c = f[0] * f[0] + f[1] * f[1] - r * r;
                var discriminant = Math.sqrt(b * b - 4 * a * c);
                var t = (-b + discriminant) / (2 * a);
                cursor.cross = [cursor.prevDisplay[0] + t * d[0], cursor.prevDisplay[1] + t * d[1]];
                if (Number.isNaN(cursor.cross[0])){
                  console.error(`WJS-ERROR: failed to compute cursor.cross\nr: ${r}\nd: ${d}\nf: ${f}\na: ${a}\nb: ${b}\nc: ${c}\ndiscrim: ${discriminant}\nt: ${t}\nprevDisplay: ${cursor.prevDisplay[0]}, ${cursor.prevDisplay[1]}`);
                }
                cursor.movementComplete = true;
                cursor.updateDisplayRealTime = exp.requireTargetHit || false;
                if (exp.renderMode=='3d'){
                  setModelParam(cursor, 'position', 0, cursor.cross[0], 0);
                  setModelParam(cursor, 'position', 0, cursor.cross[1], 1);
                }else if(exp.renderMode=='2d'){
                  cursor.position[0] = [...cursor.cross];
                }
                let xx = Math.atan2(exp.yDirection*(cursor.cross[1]-home.position[0][1]),cursor.cross[0]-home.position[0][0]);
                cursor.crossAngle = (xx > 0 ? xx : (2*Math.PI + xx));
              }
              break;
          }

          if (state.current >= state.START && state.current <= state.FINISH) {
            trial.tFrame.push(frametime);
            trial.x.push(cursor.positionH[0]);
            trial.y.push(cursor.positionH[1]);
            trial.stateFrame.push(state.current);
          }
          cursor.lastEvent = undefined;
        }
        
      }
      
      
      function handlePointerMove(event) {
        if ( !(browserName.includes('Chrome') || browserName.includes('Edge')) ||
              (!document.pointerLockElement && requireFullscreen) ||
              Object.keys(trial).length === 0 ) {
          return;
        }
        
        var eSeq = event.getCoalescedEvents();
        for (let e of eSeq){
          trial.dxCo.push(e.movementX);
          trial.dyCo.push(-e.movementY);
          trial.tCo.push(e.timeStamp);
          trial.stateCo.push(state.current);
        }
      }
      
      function handleClick(event){
        // Only handle clicks in "real" trial states
        if (Object.keys(trial).length !== 0 && !isMember(state.current, [state.FULLSCREEN, state.CONNECTION, state.PAUSE])){
          // Handle click counting in demo trial
          if(trial.demoTrial && clickTimer.elapsedMSec() > exp.instructionsClickWaitTime){
            state.numClicks += 1;
            clickTimer.reset();
          }
          // Handle click for enabling the ball
          if (state.current===state.START && state.expiredMSec(50) && cursor.disableMovement && event.which===1) {
            trial.enableMovementClickTime = event.timeStamp;
            cursor.disableMovement = false;
          }
        }
      }
      
      function setDisplayedCursorPosition(){
        // set the old cursor position (for figuring out if cursor went through something)
        cursor.prevDisplay = [...cursor.position[0]];
        
        if (trial.rotation!==0){
          // compute cursor perturbation
          var x = cursor.positionH[0] - home.position[0][0];
          var y = exp.yDirection*(cursor.positionH[1] - home.position[0][1]);
          // rotation matrix
          var sa = Math.sin(trial.rotation);
          var ca = Math.cos(trial.rotation);
          // counter-rotation matrix
          var sa_r = Math.sin(-trial.rotation);
          var ca_r = Math.cos(-trial.rotation);
          // rotate and clamp to boundaries
          var xRotated = home.position[0][0] + (x * ca - y * sa);
          var yRotated = home.position[0][1] + exp.yDirection*(x * sa + y * ca);
          if (cursor.updateDisplayRealTime){
            if (exp.renderMode=='3d'){
              setModelParam(cursor, 'position', 0, clamp(xRotated, cursor.xmin, cursor.xmax), 0);
              setModelParam(cursor, 'position', 0, clamp(yRotated, cursor.ymin, cursor.ymax), 1);
            }else if (exp.renderMode=='2d'){
              cursor.position[0] = [clamp(xRotated, cursor.xmin, cursor.xmax),clamp(yRotated, cursor.ymin, cursor.ymax)];
            }
          }
          // counter-rotate the actual cursor position so it is accurate wrt any clamp
          var x2 = cursor.position[0][0] - home.position[0][0];
          var y2 = exp.yDirection*(cursor.position[0][1] - home.position[0][1]);
          cursor.positionH[0] = home.position[0][0] + (x2 * ca_r - y2 * sa_r);
          cursor.positionH[1] = home.position[0][1] + exp.yDirection*(x2 * sa_r + y2 * ca_r);
        }else{
          if (cursor.updateDisplayRealTime){
            if (exp.renderMode=='3d'){
              setModelParam(cursor, 'position', 0, clamp(cursor.positionH[0], cursor.xmin, cursor.xmax), 0);
              setModelParam(cursor, 'position', 0, clamp(cursor.positionH[1], cursor.ymin, cursor.ymax), 1);
            }else if (exp.renderMode=='2d'){
              cursor.position[0] = [clamp(cursor.positionH[0], cursor.xmin, cursor.xmax),clamp(cursor.positionH[1], cursor.ymin, cursor.ymax)];
            }
          }
          cursor.positionH[0] = cursor.position[0][0];
          cursor.positionH[1] = cursor.position[0][1];
        }
      }

      function planLaunchMovement(type,duration){ // type=1 for smooth cosine vel, 2 for uniform
        cursor.launchType = type;
        cursor.launchDuration = duration;
        cursor.launchTimer.reset();
        cursor.startPosition = [...cursor.position[0]];
        cursor.launchVector = cursor.positionH.map((x,idx) => x - cursor.startPosition[idx]);
        console.log(`WJS: planLaunchMovement to (${cursor.launchVector.map(x=>round(x,1))}) complete.`);
      }
      
      function executeLaunchMovement(){
        var pT = Math.min(cursor.launchTimer.elapsedMSec() / cursor.launchDuration, 1);
        pT = Math.pow(pT, 1/2.5); // skew the movement profile so faster at start (but same path)
        // To plot the actual vel profile in R: plot(1-cos(2*pi*seq(0,1,len=1000)^(1/2.5)),type='l')
        var finished = pT===1;
        if (cursor.launchType===1){
          let pTRad = 2 * Math.PI * pT; // pT as a proportion of one cycle of the cos profile = 2*pi
          let V = cursor.launchVector.map(x => x / (2 * Math.PI)); // distance as proportion of integral(0 -> 2*pi) of cos profile = 2*pi
          let tmp = cursor.startPosition.map((x, idx) => x + V[idx] * (pTRad - Math.sin(pTRad)));
          setModelParam(cursor, 'position', 0, clamp(tmp[0], cursor.xmin, cursor.xmax), 0);
          setModelParam(cursor, 'position', 0, clamp(tmp[1], cursor.ymin, cursor.ymax), 1);
        }else if (cursor.launchType===2){
          cursor.currentAngle = cursor.startAngle + cursor.movementAngle * pT;
        }
        return finished;
      }

      function cursorHitGainTarget(){
        return (cursor.distanceToTarget < (target.radius + cursor.radius) && cursorInGainRegion())
      }

      function cursorInGainRegion(){
        // NB special cases: cursor angle = 350, target angle = 10 (or vice versa), target span = 50 deg
        // This is a hit, but abs(cursor angle - target angle) > target span / 2 
        // so recode the target at 10 + 360 degrees to detect this properly
        return (Math.abs(cursor.angle - trial.targetAngle) < exp.gainTargetSpan/2 ||
                Math.abs(cursor.angle - 2*Math.PI - trial.targetAngle) < exp.gainTargetSpan/2 ||
                Math.abs(cursor.angle + 2*Math.PI - trial.targetAngle) < exp.gainTargetSpan/2);
      }
      
    </script>
  </body>

</html>
